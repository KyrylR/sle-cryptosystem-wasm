%% ****** Start of file kryvyi_ryabov_article.tex ****** % Choose a filename
%% Based on the CEUR-WS template provided
\documentclass{ceurart}

%% Fix some overfulls
\sloppy

%% Language and Input Encoding
\usepackage[ukrainian]{babel} % Already included in ceurart, but safe to keep
% \usepackage[utf8]{inputenc} % Already included in ceurart

%% Graphics, Math, and other packages from original article
\usepackage{graphicx} % ceurart loads this, but explicit call is fine
\usepackage{bezier}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}   % For theorem environments

%% Define theorem environments (using original names)
\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лема}
\newtheorem{utver}{Твердження}
\newtheorem{corollary}{Наслідок}
\newtheorem{dFn}{Означення}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% Rights management information.
\copyrightyear{2025} % ** UPDATED YEAR - PLEASE VERIFY **
\copyrightclause{Copyright © 2025 for this paper by its authors. Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).} % Default CC-BY, Updated Year

%%
%% Conference information: ** UPDATED - PLEASE VERIFY **
\conference{15-та Міжнародна науково-практична конференція з програмування УкрПрог-2025, 13-14 травня 2025, Київ, Україна}

%%
%% The "title" command
\title{Симетрична криптосистема на основі відображень кілець}

%% No title notes needed for this article
% \tnotemark[1]
% \tnotetext[1]{Optional title footnote text.}

%%
%% Authors and Affiliations - UPDATED with ORCIDs and Ukrainian University Name
\author[1]{С.Л. Кривий}[%
orcid=0000-0003-4231-0691, % Added ORCID
email={sl.krivoi@gmail.com},
% url={http://example.com/slk}, % ** Optional: FILL IN URL **
]
\address[1]{Київський національний університет імені Тараса Шевченка, проспект Академіка Глушкова 4д, Київ, 03680, Україна} % Updated affiliation in Ukrainian

\author[1]{К.С. Рябов}[% % Points to the same address [1]
orcid=0009-0003-4118-8492, % Added ORCID
email={kyryl.ryabov@gmail.com},
% url={http://example.com/kr}, % ** Optional: FILL IN URL **
]
% \address[2]{...} % Removed address[2] as it's not needed


%% No corresponding author or equal contribution notes needed
% \cortext[1]{Corresponding author.}
% \fntext[1]{These authors contributed equally.}

%%
%% The abstract
\begin{abstract}
 Пропонуються алгоритми обміну інформацією між абонентами на основі
 сюр'єктивних відображень скінченних асоціативно-комутативних кілець з
 одиницею та систем лінійних рівнянь над такими кільцями. Наводяться
 алгоритми побудови скінченних кілець, побудова
 сюр'єктивних відображень кілець,  а також протокол обміну
 інформацією та обчислювальні особливості засобів реалізації
 протоколу. Основною мотивацією розробки такої криптосистеми є
 те, що практично всі існуючі криптосистеми потребують обчислення
 або великих простих чисел,  або побудови скінченних полів великих
 порядків. А такі обчислення та побудови потребують застосування
 досить складних алгоритмів. Пропонована система не потребує
 громіздких обчислень, не потребує побудови таблиць операцій кілець
 і її стійкість ґрунтується на комбінаторній складності множини
 сюр'єктивних відображень та ізоморфізмів між скінченними кільцями
 відносно невеликих порядків. Алгоритми розв'язання систем лінійних
 рівнянь, які фігурують в протоколі обміну інформацією,  над такими
 кільцями мають поліноміальну складність.
 Робота криптосистеми демонструється на прикладах.
\end{abstract}

%%
%% Keywords
\begin{keywords}
  Криптографія \sep % ** REVIEW/EDIT KEYWORDS **
  Симетрична криптосистема \sep
  Скінченні кільця \sep
  Сюр'єктивні відображення \sep
  Системи лінійних рівнянь \sep
  Ізоморфізм кілець
\end{keywords}

%%
%% Build the front matter
\maketitle

% --- CONTENT FROM THE ORIGINAL FILE STARTS HERE ---

\section{Вступ}
В криптографічних застосуваннях часто використовуються
скінченні поля і Діофантові рівняння та системи таких рівнянь \cite{1,2}.
Це пояснюється тим, що скінченне поле має циклічну мультиплікативну групу
і в такій групі ефективне використання функції дискретного логарифму, а
алгоритми розв'язання Діофантових рівнянь та систем таких рівнянь
у множині натуральних чисел мають велику часову складність \cite{3}.
Криптосистеми, побудовані на таких структурах потребують побудови великих
простих чисел, або полів великих порядків, або великих об'ємів пам'яті
та часових затрат на підготовчі дії \cite{4}.

Мотивацією даної роботи є створення криптосистеми, яка
побудована на об'єктах відносно невеликих розмірів і яка має
необхідний запас стійкості до злому. Такого типу система була
запропонована в роботі \cite{5} і ця робота є подальшим її
розвитком. Основою криптосистеми є сюр'єктивні відображення
скінченних кілець та їх ізоморфізми з використанням систем
лінійних рівнянь над кільцями лишків. Надійність такої системи
ґрунтується на комбінаторній складності множини відображень
між кільцями, порядки яких невеликі.

Системи лінійних рівнянь над кільцем лишків використовується
для формування і шифрування повідомлення, що дає можливість
практично повністю унеможливити застосування методів частотного
аналізу та гамування.

\section{Необхідні означення та поняття}
Нехай \(Z_k\) означає скінченне кільце лишків за модулем
\(k\), тобто \(Z_k\) -- це асоціативно-комутативне кільце (АК-кільце)
з одиницею.
Елементи \(a,b\in Z_k\setminus \{0\}\) називаються протилежними,
якщо \(a+b\equiv 0\pmod{k}\), і називають {\em дільниками нуля},
якщо \(a\cdot b \equiv 0\pmod{k}\). Оскільки кільце \(Z_k\) з одиницею,
то елементи \(c,d \in Z_k\) такі,
що \(c\cdot d \equiv 1\pmod{k}\), називають {\em дільниками одиниці}.
Дільники одиниці в кільці \(Z_k\) утворюють абелеву групу \cite{6}.

Нехай \(G_k\) означає скінченне АК-кільце з одиницею, ізоморфне
кільцю \(Z_k\), побудова якого виконується за заданим рядком додавання
з одиницею. Цей рядок називатимемо {\em визначальним} і за ним на
підставі законів, яким задовольняють операції додавання і множення
кільця, будуються таблиці цих операцій (алгоритми побудови таблиць
кільця \(G_k\) можна знайти в \cite{5}). Цей рядок задає також ізоморфізм
між кільцем \(Z_k\) і кільцем \(G_k\), який дає можливість уникнути
побудови таблиць операцій кільця \(G_k\), тому що операції можна
виконувати в кільці \(Z_k\) і за ізоморфізмом знаходити результати
операцій в кільці \(G_k\), а в кільці \(Z_k\) операції виконуються
ефективніше.

В загальному випадку визначальний рядок кільця \(G_k\)
\(a=(1,a_1,a_2,\ldots,a_{k-2},0)\) задається таким
відображенням \(f(0)=0+1=1, f(1)=1+1=a_1, f(a_i)=a_i+1=a_{i+1},
f(a_{k-2})=a_{k-2}+1=a_{k-1}=0,\) де \(i=0,1,\ldots,k-1\).

Визначальний рядок кільця \(G_k\) генерується таким алгоритмом.

{\footnotesize % Consider if footnotesize is appropriate here or just normal text
\begin{flushleft} % Or use a description list or similar environment
\textbf{GEN-G\((a,c,l,k)\)}

{\em Вхід:} Порядок \(k\) і коефіцієнти виразу \(f(i) = a\cdot i + c\),
            де \(k=lm\), НСД\((a,m)\)=НСД\((a,k)\)=1.

{\em Вихід:} Рядок таблиці додавання з одиницею у вигляді одномірного
             масиву \(b=(b_1,b_2,\ldots,b_k)\) довжини \(k\).

{\em Метод:}
\begin{enumerate}
    \item for \(i=0\) to \(k-1\) do \(b[i+1] := a\cdot i + c \pmod{k}\) od
    \item За спільними правилами перетворити масив \(b\) і зафіксувати
          його значення (створення спільного визначального рядка).
    \item for \(i=1\) to \(k\) do
        \begin{itemize}
            \item[] if (\(b_i = 0\land i\not= k\)) then change \(b_i\) and \(b_k\);
            \item[] if (\(b_i = 1 \land i\not= 1\)) then change \(b_i\) and \(b_1\);
        \end{itemize}
          od

          (* задання ізоморфізму \(g(i)=b_i\), де \(i=1,2,\ldots,k\) *)
    \item за масивом \(b=(b_1,b_2,\ldots,b_k)\) будуємо масив
          \(P[1\times k]\) (за яким в разі потреби будуються
          таблиці операцій кільця)

          \(P[0]:=b_1;\)

          for \(i=1\) to \(k-2\) do \(P[b_i]:= b_{i+1}\) od

          \(P[b_{k-1}]:= 0.\)
\end{enumerate}
\end{flushleft}
} % End footnotesize

\textbf{Правильність алгоритма} випливає з того, що коли НСД\((a,k)\)=1
і \(i\) пробігає повну систему лишків, то \(a\cdot i + c\) теж пробігає
повну систему лишків \cite{6}.

\textbf{Часова складність} алгоритму GEN-\(G\) -- \(O(k\log^2 k)\),
оскільки множення цілих чисел має складність \(O(\log^2 k)\),
а всіх таких множень не більше ніж \(k\).

Зазначимо, що оператор 1) алгоритму GEN-\(G\) може згенерувати не
більше ніж \((k-2)\varphi(k)\) початкових рядків, де \(\varphi\) -- функція
Ойлера. Для криптографічних застосувань такої кількості не
достатньо. Тому за домовленістю між абонентами згенерований
алгоритмом початковий рядок оператором 2) перетворюється однаковим
чином, що визначає криптосистему як симетричну.

\vspace{0.15cm} % Consider removing manual spacing

{\footnotesize % Consider if footnotesize is appropriate here
\textbf{Приклад 1.} Згенерувати визначальний рядок для
\(k=6\) і \(f(i)=i + 4\).

Перший цикл алгоритму (оператор 1) генерує такий початковий рядок:
\begin{flushleft} % Or use itemize/enumerate
\begin{enumerate}
    \item \(b_1=4; \ b_2=5; \ b_3=0; \ b_4=1; \ b_5=2; \ b_6=3\).
    \item Другий оператор виконує перетворення: міняє пари сусідніх елементів
          місцями і виконує одну циклічну перестановку всіх елементів. Дістаємо
          рядок \(2,5,4,1,0,3\).
    \item Другий цикл (оператор 3) розставляє на свої місця 0 і 1 та
          видає визначальний рядок і ізоморфізм: \(g(i)=b_i, i=1,2,\ldots,6,\) де
          \[ b_1 = 1; \ b_2=5; \ b_3=4; \ b_4 = 2; \ b_5 = 3; \ b_6 = 0. \]
    \item Третій цикл (оператор 4) генерує за масивом \(b_1=1,
          b_2=5, b_3=3, b_4=0, b_5=2, b_6=4\) рядок \(P=(1,5,3,0,2,4)\), за яким
          будуються таблиці операцій кільця \(G_6\). $\spadesuit$\footnote{ Символи $\spadesuit$
          і $\blacksquare$ означають кінець прикладу і кінець доведення відповідно.}
\end{enumerate}
\end{flushleft}
} % End footnotesize

Отже, ізоморфізм кілець \(G_k\) і \(Z_k\) знаходиться за визначальним рядком,
який згенерований алгоритмом GEN-\(G\). Дійсно, маємо таку відповідність:
\begin{center}
{\footnotesize % Consider normal size
\begin{tabular}{|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|}
\hline
 1 & 2     & 3       & 4           & \(\ldots\) & \(k-1\) & \(k\)\\
\hline
 \(b_1\) & \(b_2\) & \(b_3\) & \(b_4\) & \(\ldots\) & \(b_{k-1}\) & 0\\
\hline
\end{tabular} , }
\end{center}
де ізоморфне відображення \(g\) буде таким: \(g(k)=0, g(1)=b_1=1,
g(i)=b_i, i=2,\ldots, k-1\).

\section{Протокол обміну повідомленнями}
Ідея побудови криптосистеми ґрунтується на такій схемі:

% --- Diagram using picture environment ---
\begin{figure}[ht] % Use placement specifier like [ht] - here, top
  \centering
  \unitlength=0.80mm % Adjust unit length if needed for scaling
  \special{em:linewidth 0.4pt}
  \linethickness{0.4pt}
  \begin{picture}(98.00,55.00)(0,0) % Adjusted coordinates if needed
    \put(63.00,52.33){\makebox(0,0)[cc]{{\small \(G_m\)}}}
    \put(63.00,10.00){\makebox(0,0)[cc]{{\small \(G_m\)}}}
    \put(98.00,31.00){\makebox(0,0)[cc]{{\small \(G_k\)}}}
    \put(95.33,31.33){\vector(-3,2){28.00}}
    \put(97.67,52.33){\makebox(0,0)[cc]{{\small \(G_k/\psi\)}}}
    \put(80.00,44.33){\makebox(0,0)[cc]{{\scriptsize \(\psi\)}}}
    \put(79.67,17.00){\makebox(0,0)[cc]{{\scriptsize \(\lambda\)}}}
    \put(97.67,34.33){\vector(0,1){15.00}}
    \put(80.33,55.00){\makebox(0,0)[cc]{{\scriptsize \(\psi_1\)}}}
    \put(97.67,10.00){\makebox(0,0)[cc]{{\small \(G_k/\lambda\)}}}
    \put(97.67,27.33){\vector(0,-1){15.00}}
    \put(80.33,7.00){\makebox(0,0)[cc]{{\scriptsize \(\lambda_1\)}}}
    \put(83.00,9.67){\vector(1,0){7.00}}
    \put(85.67,52.33){\vector(1,0){4.33}}
    \put(85.67,52.33){\vector(-1,0){18.33}}
    \put(83.33,9.67){\vector(-1,0){16.33}}
    \put(30.00,31.00){\makebox(0,0)[cc]{{\small \(Z_m\)}}}
    \put(44.67,44.67){\makebox(0,0)[cc]{{\small \(\varphi\)}}}
    \put(44.67,18.00){\makebox(0,0)[cc]{{\small \(\varphi\)}}}
    \put(59.67,51.00){\vector(-3,-2){26.00}}
    \put(59.67,11.67){\vector(-4,3){26.00}}
    \put(54.00,47.00){\vector(3,2){5.33}}
    \put(55.33,15.00){\vector(3,-2){4.67}}
    \put(95.33,29.00){\vector(-2,-1){29.33}}
  \end{picture}
  \caption{Схема системи} % Caption below the figure
  \label{fig:schema} % Label for cross-referencing
\end{figure}
% --- End Diagram ---

В цій схемі відображення (див. Рис.~\ref{fig:schema}): % Example cross-reference

-- \(\varphi\) -- ізоморфізм між кільцями \(Z_m\) і \(G_m\),

-- \(\psi\) -- сюр'єкція кільця \(G_k\) на кільце \(G_m\),

-- \(\lambda\) -- сюр'єкція кільця \(G_k\) на кільце \(G_m\),

-- \(\psi_1\) -- бієкція між фактор множиною \(G_k/\psi\) і кільцем \(G_m\),

-- \(\lambda_1\) -- бієкція між фактор множиною \(G_k/\lambda\) і кільцем \(G_m\).

Обмін повідомленнями між Алісою і Бобом виконується за таким
протоколом.

Попередньо Аліса і Боб секретним каналом обмінюються четвіркою
\((a,c,l,m)\), елементи якої є параметрами алгоритму GEN-G\((a,c,l,m)\).
За допомогою виразу \(f(i) = a\cdot i + c\), де НСД\((a,k)\)=
НСД\((a,m)\)=1, згенерували початкові рядки кілець \(G_k\) і \(G_m\) і
за домовленістю
однаковим способом побудували визначальні рядки \(b=(b_1=1, b_2,
\ldots,b_{m-1},b_m=0)\) і \(c=(c_1=1,c_2,\ldots,c_k=0)\) кілець \(G_m\)
і \(G_k\) відповідно.

Після цього Аліса і Боб виконують такі кроки.

\textbf{Крок 1.} \ а) Аліса будує систему виразів в кільці \(G_m\):
\[
l(x)= Ax = \begin{cases}
  a_{11}x_1+ a_{12}x_2 +\ldots + a_{1q}x_q, \\
  a_{21}x_1+ a_{22}x_2 +\ldots + a_{2q}x_q, \\
  \qquad \vdots \\
  a_{p1}x_1+ a_{p2}x_q +\ldots + a_{pq}x_q.
\end{cases}
\]

б) Перетворює \(l(x)\) в кільці \(G_m\) таким чином:
\[
  L(x) = Bx+a = B_r(B_{r-1}(\ldots B_2(B_1(l(x)+a)+a_1)\ldots +
a_{r-1})+a_r)+a_{r+1},
\]
де \(B_i\) -- невироджені матриці розмірності \(p\times p\), \(a, a_j\)
-- вектори розмірності \(1\times p\), \(i=1,2,\ldots,r\), \(j=1,2,\ldots, r+1\). Результатом такого перетворення є система
\[
L(x)= Bx+a = \begin{cases}
  b_{11}x_1+ b_{12}x_2 +\ldots + b_{1q}x_q + a_1, \\
  b_{21}x_1+ b_{22}x_2 +\ldots + b_{2q}x_q + a_2, \\
  \qquad \vdots \\
  b_{p1}x_1+ b_{p2}x_q +\ldots + b_{pq}x_q + a_q.
\end{cases}
\]

в) Виконує зміну коефіцієнтів у \(l(x)\) і \(L(x)\)
  їхніми відповідниками з фактор-множини \(G_k/\lambda_1\):
\[
\bar l(x)= \bar Ax = \begin{cases}
  b_{11}x_1+ b_{12}x_2 +\ldots + b_{1q}x_q, \\
  b_{21}x_1+ b_{22}x_2 +\ldots + b_{2q}x_q, \\
  \qquad \vdots \\
  b_{p1}x_1+ b_{p2}x_q +\ldots + b_{pq}x_q. % Corrected typo pqx_q -> pqx_q
\end{cases}
\]
і
\[
\bar L(x)= \bar Bx+b = \begin{cases}
  c_{11}x_1+ c_{12}x_2 +\ldots + c_{1q}x_q + b_1, \\
  c_{21}x_1+ c_{22}x_2 +\ldots + c_{2q}x_q + b_2, \\
  \qquad \vdots \\
  c_{p1}x_1+ c_{p2}x_q +\ldots + c_{pq}x_q + b_q.
\end{cases}
\]

Аліса висилає відкритим каналом або виставляє на сайті
вирази \(\bar l(x)\) і \(\bar L(x)\).

\textbf{Крок 2.} \ a) Боб за виразами \(\bar l(x)\) і \(\bar L(x)\) та відображеннями
\(\lambda_1^{-1}\) і \(\varphi^{-1}\) знаходить вирази \(\hat l(x)\) і \(\hat L(x)\)
в кільці \(Z_m\), вибирає довільний вектор \(\bar a\) розмірності \(1\times q\).

б) Боб хоче передати Алісі повідомлення \(v\). Для цього він
   розв'язує систему \(\hat l(x)=v\), знаходить розв'язок \(\bar x\)
   і обчислює вектори \(\hat l(\bar a) = d\) та \(\hat L(\bar x + \bar a) = d_1\)
   у кільці \(Z_m\).

в) Вектор \(v\) Боб зберігає в таємниці, а значення \(d\) і \(d_1\)
   замінює відповідниками однієї із фактор-множини \(G_k/\psi\) або \(G_k/\lambda\)
   і висилає Алісі відкритим каналом пару векторів \((\bar d,\bar d_1)\).

\textbf{Крок 3.} \ а) Аліса обчислює обернені матриці до матриць \(B_i\) в
   кільці \(G_m\) (а це обчислення виконується в кільці
   \(Z_m\) за ізоморфізмом \(\varphi\)).

б) Знаходить значення \(v\), оскільки всі дані для цього в неї є.

\begin{utver}
Обмін повідомленнями за протоколом виконується коректно.
\end{utver}
\begin{proof} % Using proof environment
Очевидним чином випливає з властивостей лінійних
операторів, бієкції \(\lambda_1\) та ізоморфізму \(\varphi\).
Дійсно, позначимо добуток матриць \(B_rB_{r-1}\ldots B_1= D\), тоді
\[
 d_1=L((\bar x + \bar a) + a_1) = D(l(\bar x + \bar a) + a_1) + b + a_{r+1}=
 D(l(\bar x + \bar a)+a_1) + c,
\]
де \(c = b + a_{r+1}\), а \(b\) -- вектор значень, отриманий в результаті
множення матриць \(B_1,B_2,\ldots, B_r\) на вектори \(a_1,a_2,\ldots,a_r\). Тоді
\[
D^{-1}(D(d_1-a_{r+1})) - D^{-1}b = D^{-1}(D(l(\bar x + \bar a)+a_1) + b) - D^{-1}b = l(\bar x + \bar a) + a_1.
\]
Отже, \(l(\bar x + \bar a) + a_1 - [a_1 + d] = l(\bar x)\). $\blacksquare$ % Keep the end symbol if desired
\end{proof}

З рисунка~\ref{fig:schema} випливає, що в схемі системи існує принаймні три
шляхи створення шифрограми:

1) \(G_k/\psi \to G_m \to Z_m \to G_m\) означає, що явно
фігурують вирази \(l(x)\) і \(L(x)\), записані у фактор-множині
\(G_k/\psi\), які за бієкціями \(\varphi\) і \(\psi_1\) відтворюються
у кільці \(Z_m\), де виконуються обчислення і будується шифрограма
в кільці \(G_m\).

2) \(G_k/\lambda \to G_m \to Z_m \to G_k/\psi\) означає, що
явно фігурують вирази \(l(x)\) і \(L(x)\) записані у фактор-множині
\(G_k/\lambda\), за бієкціями \(\lambda_1\) і \(\varphi\) ці вирази
відтворюються у кільці \(Z_m\), де виконуються
обчислення і будується шифрограма за бієкціями
\(\varphi\) і \(\psi_1\) у фактор-множині \(G_k/\psi\).

Цьому шляху відповідає вищенаведений протокол.

3) \(G_m/\psi \to G_m \to Z_m \to G_k/\lambda\) означає, що
явно фігурують вирази \(l(x)\) і \(L(x)\) записані у фактор-множині
\(G_k/\psi\), за бієкціями \(\psi_1\) і \(\varphi\) ці вирази
відтворюються у кільці \(Z_m\), де виконуються
обчислення і будується шифрограма у фактор-множині
\(G_k/\lambda\).

{\footnotesize % Consider normal size
\textbf{Приклад 2.} Розглянемо підготовчі дії протоколу.

Нехай Аліса і Боб вибрали перший шлях створення шифрограми, обмінялися
трійкою \((7,5,2,25)\) і зафіксували такий визначальний рядок кільця
\(G_{25}\) (виконали оператори 1) і 2)):
\begin{center}
 \(b=(1,6,8,10,2,4,3,5,7,9,11,13,15,17,19,21,12,14,16,18,20,24,
     22,23,0).\)
\end{center}
Оператор 3) алгоритму GEN-\(G(7,5,2,25)\) визначає ізоморфне відображення
\(\varphi: Z_{25}\to G_{25}\), яке в даному випадку набуває вигляду:
\begin{center}
\begin{tabular}{lllll}
\(\varphi(0)= 0,\) & \(\varphi(5)=2,\) & \(\varphi(10)=9,\)  & \(\varphi(15)=19,\) & \(\varphi(20)=18,\)\\
\(\varphi(1)= 1,\) & \(\varphi(6)=4,\) & \(\varphi(11)=11,\) & \(\varphi(16)=21,\) & \(\varphi(21)=20,\)\\
\(\varphi(2)= 6,\) & \(\varphi(7)=3,\) & \(\varphi(12)=13,\) & \(\varphi(17)=12,\) & \(\varphi(22)=24,\)\\
\(\varphi(3)= 8,\) & \(\varphi(8)=5,\) & \(\varphi(13)=15,\) & \(\varphi(18)=14,\) & \(\varphi(23)=22,\)\\
\(\varphi(4)=10,\) & \(\varphi(9)=7,\) & \(\varphi(14)=17,\) & \(\varphi(19)=16,\) & \(\varphi(24)=23,\)\\
\end{tabular}
\end{center}
де \(\varphi(25)=\varphi(0)=0, \varphi(1)=1, \varphi(2)=\varphi(1+1)=6, \varphi(3)=6+1=8, \varphi(4)=8+1=10,
\ldots,\varphi(24)=23\).

За цим ізоморфізмом оператор 4) алгоритму GEN-G будує масив
\(P[1\times 25]\) (для зручності читання він поданий нижнім рядком
підстановки).
\[ % Using pmatrix for alignment
P=\begin{pmatrix}
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14  &
15 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23 &  24\\
1&6&4&5&3&7&8&9&10&11&2&13&14&15&16&17&18&19&20&21&24&12&23&0&22\\
\end{pmatrix}.
\]

Нехай літери алфавіту англійської мови перенумеровані природним чином:
\begin{table}[ht] % Use table environment
 \centering
 \caption{Цифрові відповідники символів алфавіту} % Caption above table
 \label{tab:alphabet}
 \vspace{0.1cm} % Consider removing manual space
 \begin{tabular}{ % Use booktabs rules if desired (remove |)
 |c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|
 c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|}
 \hline
 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14  &
 15 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23 &  24\\
 \hline
 a & b & c & d & e & f & g & h & i/j & k & l & m & n & o & p & q &
 r & s & t & u & v & w & x & y & z\\
 \hline
 \end{tabular}
\end{table}
і визначальний рядок кільця \(G_{50}\), згенеруваний алгоритмом GEN-\(G\),
має вигляд
\begin{center} % Consider breaking this long line or using a different environment
1,5,49,7,10,17,2,34,11,20,39,33,48,3,45,4,37,6,41,13,43,15,36,8,38,9,
35,12,40,14,44,19,46,16,47,21,31,24,27,42,29,22,32,23,30,25,28,18,26,0.
\end{center}

Задаючи бієкцію \(\psi_1\) кільця \(G_{50}\)\footnote{В якості \(G_{50}\) можна
взяти довільну множину потужності \(25\cdot l\), a Аліса і Боб повинні однаковим
чином упорядкувати елементи цієї множини і побудувати бієкцію \(\lambda_1\).},
на кільце \(G_{25}\) вигляду
\[
\psi_1= \begin{cases}
\psi(0) = 7=m_0, & i=0 \\
\psi(i \pmod{25}) = m_{i-1} +1, & i \geq 1,
\end{cases}
\]
де \(i=1,2,\ldots,50\), дістаємо порядковий номер \(j\) класу елемента \(m_i\):\\

\begin{table}[ht] % Use table environment
 \centering
 \caption{Відображення класів \(G_{50}\) на \(G_{25}\)} % Caption above table
 \label{tab:class_mapping}
 \begin{tabular}{ % This table might be too wide for CEUR's layout - consider table* or reformatting
 |c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|
 c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|c@{}|}
 \hline
 0&1&2&3&4&5&6&7&8&9&10&11&12&13&14&15&16&17&18&19&20&21&22&23&24\\
 \hline
 7&10&17&2&34&11&20&39&33&48&3&45&4&37&6&41&13&43& 15&36&8&38&9&35&12\\
 40&14&44&19&46&16&47&21&31&24&27&42&29&22&32&23&30&25&28&18&26&0&1& 5&49 \\
 \hline
 a &b &c &d &e&f&g&h&i/j&k&l&m&n&o&p&q&r&s&t&u&v&w&x&y& z\\
 \hline
 \end{tabular}
\end{table}

На цьому підготовчі дії закінчуються. $\spadesuit$
} % End footnotesize

\subsection{Криптоаналіз протоколу}
Розглянемо варіанти криптоаналізу розглянутого протоколу.
Криптоаналітику доступні такі дані:

а) система \(\bar L(x)\), з якої за кількістю конгруенцій у системі
   знаходиться довжина блоків повідомлення;

б) довжина шифрограми, яка знаходиться за кількістю невідомих у
    конгруенціях;

в) можливо порядки кілець \(G_m\) і \(G_k\).

Невідомими є ізоморфізм \(\varphi\), бієкції \(\psi_1, \lambda_1\) та
сюр'єкції \(\psi\) і \(\lambda\).

ї) Припустимо, що у варіанті а) криптоаналітику більше нічого
не відомо. Тоді можливим способом отримати відкритий текст є
метод повного перебору. Складність такого перебору визначається
кількістю способів зашифрувати повідомлення, а ця кількість
складеться із

     1) кількості можливих ізоморфізмів (бієкцій) \(\varphi\)
        -- \(O((m-2)!)\), де \(m\) -- порядок кільця \(G_m\),

     2) кількості бієкцій \(\psi_1\) і \(\lambda_1\) -- відповідно
        \(O(m!)\),

     3) кількості сюр'єкцій \(\psi\) і \(\lambda\) -- відповідно
        \(O(\frac{k!}{m!(l!)^m})\), де \(k=lm\).

Загальна складність, навіть для такої простої криптосистеми, як у
наведеному вище прикладі складає
\[24!\cdot 26!\cdot \frac{104!}{26!24^{26}}>\frac{24!104!}{2^{120}}
 > 10^{25}.\]
Якщо припустити, що одна комбінація генерується в часі \(10^{-14}\)
сек., то для того щоб знайти всі комбінації потрібно буде
     \[10^{25}\cdot 10^{-14}=10^{11}\]
секунд, а це більше ніж \(10^{2}=100\) років.

Зрозуміло, що коли взяти порядки \(k\) і \(m\) більшими, то перебірний
метод стає незастосовним.

б) Припустимо, що у варіанті б) криптоаналітику відомі декілька
зашифрованих повідомлень, тобто йому доступні тексти
\[
 \bar m_1=\varphi(\hat d_{11},\hat d_{12}), \quad \bar m_2=\varphi(\hat
d_{21},\hat d_{22}), \quad
\bar m_3=\varphi(\hat d_{31},\hat d_{32}),
\]

Оскільки бієкцій
типу \(\varphi\) існує \((m-2)!\) і вектори \(m_1,m_2,\ldots\) належать різним
множинам, то ця інформація потребує знання бієкції \(\varphi\), тобто визначального
рядка \(G_m\). Але ці об'єкти йому не доступні і пошук цих об'єктів
перебірним
методом потребує генерації \(m!(m-2)!\) комбінацій. А за цими
комбінаціями потрібно ще знайти символьні відповідники (а це теж
\(m!\) комбінацій), то ця інформація теж не дає можливості в розумному
проміжку часу знайти текст явний.

в) Припустимо, що у варіанті в) криптоаналітику відомі зашифровані
повідомлення і розшифровані повідомлення, тобто доступні
\[
 m_1, m_2, m_3, \ldots
\]
і
\[
 m_1=\xi^{-1}(\varphi^{-1}(\bar m_1)), \quad
  m_2=\xi^{-1}(\varphi^{-1}(\bar m_2)), \quad
  m_3=\xi^{-1}(\varphi^{-1}(\bar m_3)), \ldots.
\]
де \(\xi^{-1}\) відображає цифровий текст у символьний текст.

Оскільки відображення \(\xi, \varphi\) та система \(\hat l(x)\)
криптоаналітикові невідомі, то знайти відповідники і за цими
даними визначальний рядок у нього немає можливості.

З вищенаведеного прикладу видно, що в обчислювальному сенсі найскладнішим
етапом є побудова обернених матриць в кільці \(G_m\). Для того, щоб
спростити ці обчислення, краще скористатися ізоморфізмом між
кільцями \(\varphi : G_m \to Z_m\) і вести обчислення в кільці лишків
\(Z_m\). Коли обернені матриці будуть знайдені, то виконати зворотні
підстановки і отримати відповідні матриці в кільці \(G_m\).

Як відомо, мультиплікативна група дільників одиниці кільця \(G_k\) є абелевою
групою \cite{6}. Для того, щоб в цій групі можна було застосовувати функцію
дискретного логарифма, вона повинна бути циклічною. Тобто мати твірний
елемент, який її породжує. Отже, виникає питання: за яких умов група
дільників одиниці кільця \(G_k\) буде циклічною? Відповідь на це питання дає
\begin{theorem}\label{gaus} % Keep label if cross-referenced
Мультиплікативна група кільця \(Z_k\) буде циклічною тоді і тільки
тоді, коли k дорівнює 2, 4, \(p^m\) або \(2p^m\), де \(m\geq 1\), p --
непарне просте число \cite{6}.
\end{theorem}


\section{Формування повідомлення}
Зі сказаного випливає, що Аліса і Боб повинні обмінятися
закритим каналом числами \((a,c,l,k)\), де \(a,c,l,k\) -- параметри
алгоритма GEN-G\((a,c,l,k)\). Якщо вибрати порядок кільця \(k\) кратним
порядку кільця \(Z_m\), тобто \(k=l\cdot m\), то на підставі взаємної
простоти чисел \(k,m\) і \(a\), способи побудова кілець будуть відомі,
а перетворення з метою побудови визначальних рядків кілець взяти
однаковими для \(G_k\) і \(G_m\).

Далі з наведеного протоколу і прикладу випливає, що для передачі
потрібного повідомлення \(b=(b_1,b_2,\ldots,b_p)\) необхідно щоб
система рівнянь
\begin{equation}\label{eq4} % Keep label if cross-referenced
l(x)=Ax= \begin{cases}
  a_{11}x_1+ a_{12}x_2 +\ldots + a_{1q}x_q \equiv b_1, \\
  a_{21}x_1+ a_{22}x_2 +\ldots + a_{2q}x_q \equiv b_2, \\
  \qquad \vdots \\
  a_{p1}x_1+ a_{p2}x_q +\ldots + a_{pq}x_q \equiv b_p
\end{cases} \pmod{m}
\end{equation}
мала розв'язок для довільних значень \(b_1,b_2,\ldots,b_p\).
Ізоморфізм кілець \(G_m\) і \(Z_m\) дозволяє розглядати лише кільце
лишків \(Z_m\). Критерій сумісності СЛНДР \(Ax\equiv b \pmod{m}\) розмірності
\(p\times q, (p < q)\) над кільцем \(Z_m\) вимагає існування розв'язку порівняння
   \[d_1y_1+d_2y_2+\ldots +d_sy_s\equiv 1 \pmod{m},\]
де \(d_1,d_2,\ldots,d_s\) -- значення останніх координат у розв'язках СЛОДР
\(Ax-bx_0=0\) \cite{7}. Ця умова виконується для довільного \(b\), якщо
рівняння системи лінійно незалежні і детермінант матриці підсистеми
\(A_1u\equiv b \pmod{m}\) розмірності \(p\times p\), яка утворена лінійно
незалежними стовпчиками \(b_{i_1},b_{i_2},\ldots,b_{i_p}\) СЛНДР \(Ax\equiv
b \pmod{m}\), взаємно простий з модулем \(m\). Тоді для матриці
підсистеми існує обернена матриця, тобто із \(A_1u=b \pmod{m}\) випливає
\(A^{-1}_1A_1u=u\equiv A_1^{-1}b \pmod{m}\) для довільного \(b\). A вектор
\(a=(a_1,a_2,\ldots,a_q)\), у якого номери координат \(i_1,i_2,\ldots,i_p\)
такі як у вектора \(u\equiv A_1^{-1}b \pmod{m}\) a решта координат мають
нульові значення, буде розв'язком СЛНДР.

Отже, Алісі потрібно будувати СЛР, у якої рівняння лінійно незалежні
і мають підсистему з детермінантом її матриці, який взаємно простий з
модулем \(m\). Для перевірки лінійної незалежності виразів Алісі потрібно
розв'язати систему \(A^Ty\equiv 0 \pmod{m}\) і переконатися, що
ця система має лише нульовий розв'язок. Потім побудувати
підсистему з описаними властивостями детермінанта її матриці.

{\footnotesize % Consider normal size
\textbf{Приклад 3.} Нехай літери алфавіту англійської мови перенумеровані
природним чином (див. табл.~\ref{tab:alphabet}).

\textbf{Крок 1.} а) Нехай Аліса побудувала в кільці \(G_{25}\) такі вирази
(в дужках показані вирази, де від'ємні коефіцієнти замінені своїми
протилежними):
\[
l(x)= \begin{cases}
  2x_1 -16x_2 +  7x_3 + 20x_4,\\
  0x_1 + 1x_2 - 17x_3 - 11x_4
\end{cases}
\quad \Biggl ( \begin{cases}
  2x_1 + 4x_2 +  7x_3 + 20x_4,\\
  0x_1 + 1x_2 + 11x_3 + 17x_4
\end{cases} \Biggr )
\]
і перетворила їх до вигляду
\[
L(x)= B_1(l(x)+ (1,2)^t) =
\begin{cases}
  9x_1 - 13x_2 + 10x_3 - 16x_4 + 3,\\
 18x_1 + 14x_2 - 18x_3 + 19x_4 +16,
\end{cases}
\Biggl (
\begin{cases}
  9x_1 + 15x_2 + 10x_3 + 4x_4 + 3,\\
 18x_1 + 14x_2 + 2x_3 + 19x_4 +16,
\end{cases}
\Biggr )
\]
де матриця
\begin{center} % Center the matrix display
\(
B_1= \begin{pmatrix}
   6 & 1\\
   23 & 23
\end{pmatrix}
\)
\quad і її відповідник у кільці \(Z_{25}\) \quad
\(
\bar B_1 = \begin{pmatrix}
   2 & 1\\
  -1 & -1
\end{pmatrix}.
\)
\end{center}

в) Аліса виконує заміну коефіцієнтів у побудованих
виразах \(l(x)\), \(L(x)\) і матриці \(B_1\) відповідниками з фактор
множини \(G_{50}/\psi\) і дістає вирази
\[
\bar l(x)= \begin{cases}
  17x_1 + 34x_2 +  21x_3 + 26x_4,\\
   7x_1 + 14x_2 +  42x_3 + 43x_4,
\end{cases}
\]
\[\bar L(x)= B_1(l(x)+ (1,2)^t) = \begin{cases}
  48x_1 + 41x_2 + 3x_3 + 46x_4 + 19,\\
 15x_1 + 32x_2 + 44x_3 + 36x_4 + 30,
\end{cases}
\]
які висилає Бобу відкритим каналом або виставляє на своєму сайті.

\textbf{Крок 2.} а) Боб за бієкціями \(\varphi\) і \(\psi_1\)
знаходить відповідники виразів \(\hat l(x)\) і
\(\hat L(x)\) у кільці \(Z_{25}\):
\[
\hat l(x)= \begin{cases}
  5x_1 + 6x_2 +  9x_3 + 21x_4,\\
  0x_1 + 1x_2 + 11x_3 + 14x_4.
\end{cases}
\]
\[
\hat L(x) = \begin{cases}
 10x_1 + 13x_2 + 4x_3 + 6x_4 + 7,\\
 20x_1 + 18x_2 + 5x_3 + 15x_4 + 19.
\end{cases}
\]

Неважко переконатися, що в системі виразів \(\hat l(x)\) другий і
третій стовпчики утворюють підсистему, детермінант
якої дорівнює 7, a 7 -- взаємно простий з модулем 25 в кільці \(Z_{25}\)
(умови сумісності системи \(\hat l(x)\) виконуються).

Боб хоче передати Алісі повідомлення
\begin{center}
     {\em tara tara tarara}.
\end{center}

б) Боб розбиває повідомлення на блоки по два символи в блоці
(відступи між символами повідомлення, яким відповідає елемент 49,
не враховані з метою спрощення обчислень у прикладі), замінює їх
цифровими відповідниками, які взяті з табл.~\ref{tab:alphabet}:
\begin{center}
\begin{tabular}{ccccccc}
       ta  &  ra  &  ta  &  ra  & ta   &  ra  &  ra \\
      18,0 & 16,0 & 18,0 & 16,0 & 18,0 & 16,0 & 16,0\\
\end{tabular}.
\end{center}

б) Розв'язує систему рівнянь в кільці \(Z_{25}\)
\[
\hat l(x)= \begin{cases}
  5x_1 + 6x_2 +  9x_3 + 21x_4 = 18,\\
  0x_1 + 1x_2 + 11x_3 + 14x_4 = 0.
\end{cases} \pmod{25}
\]
і знаходить розв'язок \(\bar x = (0,14,1,0)\).

в) Значення \(v_1 = (18,0)\) він тримає в секреті.
Обирає вектор \(\bar a=(0,1,0,1)\) і обчислює значення
\(d=l(\bar a)=(2,15)\) і до розв'язку даної
системи \(\bar x = (0,14,1,0)\) додає вектор \(\bar a =
(0,1,0,1)\) і цю суму векторів \(\bar x + \bar a = (0,15,1,1)\)
підставляє в \(L(x)\), знаходячи тим самим значення
\(d_1 = (12,9)\). Відповідники значень \(d\) і \(d_1\)
у кільці \(G_m\) Боб висилає Алісі.

Аліса, за отриманими відповідниками знаходить значення \(d, d_1\),
і виконує такі обчислення.

а) Обчислює обернену матрицю до матриці \(\bar B_1^{-1}\) y кільці \(Z_{25}\):
\[
B_1^{-1}= \begin{pmatrix}
   1 & 1\\
  -1 & -2
\end{pmatrix}.
\]

б) Обчислює \(\bar B_1^{-1}(d_1^t-(7,19)^t)=\bar B_1^{-1}((12,9)-(7,19))^t=\bar B_1^{-1}(5,15)^t\) і знаходить
\[\bar B_1^{-1}(5,15)^t - (2,15)^t= (20,15) - (2,15) = (18,0)=v_1.\]

а) Боб розв'язує систему рівнянь
\[
\hat l(x)= \begin{cases}
  5x_1 + 6x_2 +  9x_3 + 21x_4 = 16,\\
  0x_1 + 1x_2 + 11x_3 + 14x_4 = 0.
\end{cases} \pmod{25}
\]
і знаходить розв'язок \(\bar x = (0,18,12,0)\).

б) Значення \(v_2 = (16,0)\) він тримає в секреті.
Обирає вектор \(\bar a=(1,0,1,0)\) і обчислює значення
\(d=l(\bar a)=(14,11)\) і до розв'язку даної
системи \(\bar x = (0,18,12,0)\) додає вектор \(\bar a = (1,0,1,0)\)
і цю суму векторів \(\bar x + \bar a = (1,18,13,0)\) підставляє в
\(L(x)\), знаходячи тим самим значення \(d_1 = (3,3)\).

в) Відповідники значень \(d\) і \(d_1\) у кільці \(G_m\) Боб
висилає Алісі.

\textbf{Крок 3.} Аліса, за отриманими відповідниками знаходить
значення \(d, d_1\) і виконує такі обчислення.

а) Знаходить обернену матрицю до \(\bar B_1^{-1}\) в кільці \(Z_{25}\):

б) Обчислює \(B_1^{-1}(d_1^t-(7,19)^t)=B_1^{-1}(21,9)^t\) і знаходить
\[\bar B_1^{-1}(21,9)^t-(14,11)^t = (5,11)+(11,14) = (16,0)=v_2.\]

б) Боб розв'язує систему рівнянь в кільці \(Z_{25}\)
\[
l(x)= \begin{cases}
  5x_1 + 6x_2 +  9x_3 + 21x_4 = 18,\\
  0x_1 + 1x_2 + 11x_3 + 14x_4 = 0.
\end{cases} \pmod{25}
\]
і знаходить розв'язок \(\bar x = (0,14,1,0)\).
Оскільки наступний блок такий самий як і перший, тобто \(v_3=(18,0)\).
Це змушує Боба вибрати новий вектор \(\bar a = (0,0,1,1)\), за яким
він обчислює значення
\[
  d=l(\bar a)=(5,0), \quad \bar x+\bar a=(0,14,2,1), \quad d_1=L(\bar x +\bar a)=(3,21).
\]
і висилає Алісі відповідники \(d=(5,0), d_1=(3,21)\) у кільці \(G_{25}\).

Аліса обчислює
\[
  B_1^{-1}(d_1^t-(7,19)^t)=B_1^{-1}(21,2)^t=(23,0)=l(\bar x+\bar a).
\]
Звідки знаходить
\[(23,0)-(5,0)=(18,0)=v_3.\]

Oскільки наступний блок такий самий як і другий, тобто
\(v_4=(16,0)\), то це змушує Боба вибрати новий вектор
\(\bar a = (0,0,0,1)\), за яким він обчислює значення
\[
  d=l(\bar a)=(21,14), \quad \bar x+\bar a=(0,18,12,1), \quad d_1=L(\bar x +\bar a)=(20,18).
\]
і висилає Алісі відповідники \(d=(21,14), d_1=(20,18)\) у кільці \(G_{25}\).

Аліса обчислює
\[
  B_1^{-1}(d_1^t-(7,19)^t)=B_1^{-1}(13,24)^t=(12,14)=l(\bar x+\bar a).
\]
Звідки знаходить
\[
   (12,14)-(21,14)=(12,14)+(4,11)=(16,0)=v_4.
\]

Цю процедуру Боб і Аліса повторюють стільки разів, скільки блоків у
повідомленні (в даному випадку ще три рази). Таким чином Аліса отримує
шифрограму
\begin{center}
\begin{tabular}{ccccccc}
  (2,15,12,9) & (14,11,3,3) & (5,0,3,21) & (21,14,20,18) & \(\cdots\) & \(\cdots\) & \(\cdots\)\\
\end{tabular}
\end{center}
Після дешифрації Аліса відкриває повідомлення
\begin{center}
\begin{tabular}{ccccccc}
      18,0 & 16,0 & 18,0 & 16,0 & 18,0 & 16,0 & 16,0\\
       ta  &  ra  &  ta  &  ra  &  ta  &  ra  &  ra\\
\end{tabular} $\spadesuit$ .
\end{center}
} % End footnotesize

В наведеному прикладі використовувалося одне і те саме кільце,
але можна при кожному сеансі передачі або з певним періодом
між передачами змінювати кільце. Можна змінювати вектори \(a\)
і \(\bar a\), які змінюють значення \(l(\bar a)\) і \(L(\bar x +\bar a)\).

Наведений протокол можна зробити складнішим, якщо використовувати
при шифруванні кожного блоку різні кільця або різні значення
параметрів -- матриць і векторів.
Крім того, якщо шифрований текст представити відповідниками
в кільці \(G_{50}\)
\begin{center}
{\footnotesize % Consider normal size
\begin{tabular}{ccccccc}
  (44,23,4,48) & (6,45,2,19) & (11,40,19,0) & (38,22,8,15) & \(\cdots\) & \(\cdots\) & \(\cdots\), \\
\end{tabular}}
\end{center}
то криптоаналітику зовсім недоступні системи виразів, кільця \(G_{25}\),
\(Z_{25}\) та відображення \(\lambda,\lambda_1,\psi,\psi_1\) і \(\varphi\).

\section{Обчислювальні особливості}
Виходячи з того, що обчислення в кільці \(G_m\) не є
звичним при обчисленнях, то покращити ефективність шифрування
і розшифрування можна, якщо знову скористатися ізоморфізмом
між кільцями \(G_m\) і \(Z_m\). Дійсно, пошук протилежного елемента
до елемента \(a\) в кільці \(Z_m\) зводиться до обчислення різниці
\(m-a\), а обчислення оберненого елемента до \(a\) виконується
шляхом застосування розширеного алгоритму Евкліда для розв'язання
рівняння \(ax + my = 1\) (розширений алгоритм Евкліда обчислює розклад
\(ax+by=d\), де \(d=\)НСД\((a,b)\)). Результатом виконання цього
алгоритму є значення \(x=a^{-1}\).

Очевидним недоліком описаного протоколу є те, що довжина шифрограми
у двічі довша тексту повідомлення.


%% The acknowledgments section - uncomment and add text if needed
% \begin{acknowledgments}
%   Подяки...
% \end{acknowledgments}

%% Declaration on Generative AI - ** CHOOSE ONE OPTION AND EDIT AS NEEDED **
\section*{Declaration on Generative AI}
  {\em Option 1 (No AI Used):}\newline
  The author(s) have not employed any Generative AI tools in the preparation of this work.
  \newline

% \noindent{\em Option 2 (AI Used - Fill in details):}\newline
%  During the preparation of this work, the author(s) used [NAME TOOL(S)/SERVICE(S)] in order to: [ACTIVITY 1], [ACTIVITY 2], etc. (Use activities from ceur-ws.org/genai-tax.html, e.g., Grammar and spelling check, Generate images, Literature search, ...). After using these tool(s)/service(s), the author(s) reviewed and edited the content as needed and take(s) full responsibility for the publication’s content.

%%
%% Bibliography
%% Using the thebibliography environment directly from the original file
\begin{thebibliography}{99} % Use a label width appropriate for the number of refs

\bibitem{1} Wenbo Mao.
 Modern Cryptography.
 Pearson Education. Prentice Hall Professional
Technical Reference Upper Saddle River. New Jersey. 2004.
768 p.

\bibitem{2} Kameswari P.A., Sriniasarao S.S., Belay A.
 An application of Linear Diophantine equations to Cryptography.
 Advanced in Mathematics: Scientific Journal. 2021. v. 10.
            P. 2799--2806.

\bibitem{3} Hermann M., Juban L., Kolaitis P. G.
 On the Complexity of Counting the Hilbert Basis of
          a Linear Diophantine System.
 Springer Verlag. LNCS. 1999. № 1705. % Using № symbol directly
          P. 13--32.

\bibitem{4} Berczes A., Lajos H., Hirete-Kohno N., Kovacs T.
 A key exchange propocol based on Diophantine equations and S-integers.
 JSIAM Letters. 2014. p. 85--88.

\bibitem{5} Kryvyi S., Opanasenko V., Grinenko O., Nortman Yu.
 Symmetric system for Exchange Information on the Base of
Surjective Isomorphism of Rings.
 {\em 12th Int. IEEE Conf. on Dependable Systems, Services and
Technologies (DESSERT 2022). 2022. December 9-11. рр. 1-7}.

\bibitem{6} Shoup V.
 An Computational Introduction to Number Theory and Algebra.
 Cambridge University Press. 2008. 580 p.

\bibitem{7} Кривий С.Л.
 Лінійні Діофантові обмеження та їх застосування.
 Київ: Інтерсервіс. 2021. 257 с.

\end{thebibliography}

%% Appendix section - uncomment and add content if needed
% \appendix
% \section{Appendix Section Title}
% Appendix content...

\end{document}
%% ****** End of file kryvyi_ryabov_article.tex ******
